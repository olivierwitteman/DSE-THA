%%% Description
%
% This routine generates the wing loading - power loading diagram for an
% aircraft featuring wing-mounted distributed propulsion (tractor, pusher
% or over-the-wing), where lift and drag depend on thrust. The following
% lift and drag (coefficient) breakdowns are assumed for stable flight:
%
% CD0 + CDi + dCD0 + dCDi = (T*cos(Gamma))/q_inf/S
%
% Where:
%   - CD0 = zero-lift drag of isolated aircraft (incl. wing), i.e. 
%       excluding propulsive system elements such as pylons, nacelles, 
%       engines, propellers, etc.
%   - CDi = lift-induced drag of isolated wing.
%   - dCD0 = increase in zero-lift, zero-thrust drag due to the DP 
%       installation (namely the increase in wetted area due to pylons and 
%       nacelles). This can be related to the "average" sectional drag 
%       coefficient increase in the DP system through dCD0 = dCd0*b_dp, 
%       where b_dp is the fraction of span occupied by the DP system. NB:  
%       the increase in drag due to the wetted area of the propeller blades  
%       in windmilling conditions is neglected.
%   - dCDi = thrust-induced drag, i.e. difference between drag of the  
%       complete aircraft (incl. wing and nacelles/pylons) when the
%       propeller is at a certain thrust setting, and the drag that would 
%       exist if the propeller is not generating thrust. dCDi =
%       dCdi*b_dp.
%   - T = thrust generated by the propeller blades in the installed
%       condiguration (which is not equal to an isolated propeller's
%       thrust). The propeller can be inclined and angle Gamma for thrust
%       vectoring, or if e.g. the propeller is attached to the flap. The
%       thrust can be divided into:
%       
% T = T_iso + dT_vMean + dT_vNonUniform + dT_alphaMean + dT_alphaNonUniform
%
%       where T_iso is the thrust of an isolated propeller at zero
%       incidence, and dT_vMean and dT_vNonUniform the changes in propeller
%       thrust due to changes in mean inflow velocity and non-uniform
%       inflow velocity respectively (vNonUniform = vInflow - vMean, where
%       vMean = mean(vInflow)). dT_alphaMean and dT_alphaNonUniform are
%       changes in propeller thrust due to changes in mean angle of attack
%       and non-uniform angle of attack respectively. The angle of attack
%       of the propeller is defined as the angle between the propeller axis
%       and the incoming flow velocity, which can be non-zero due to a) the
%       propeller deflection angle Gamma, and b) due to the velocity field
%       generated by the wing. 
%
% W/q_inf/S = CL + dCL + (T*sin(Gamma))/q_inf/S
%
%   - W = weight of the complete aircraft [N]
%   - CL = lift coefficient of the isolated wing, which is assumed to be
%       the only lifting surface.
%   - dCL = increase in wing lift coefficient due the thrust generated by
%       the propeller. dCL = dCl*b_dp.
%
% All coefficients in the previous equations are non-dimensionalized with
% the wing reference area S and the dynamic pressure of the freestream
% q_inf. This breakdown has been selected since the individual
% contributions can be obtained from experiments and simulations. All
% "delta" terms (dCDi, dT_vMean, etc.) will be based on (semi-) empirical
% relations. Therefore, for an accurate diagram, accurate correlations
% between e.g. propeller thrust and wing lift/drag increase are required.
% Furthermore, the previous equations hold for horizontal flight without
% acceleration. In the code they contain additional terms due to e.g.
% maneuvering, climbing or accelerating.
%
% A power loading diagram is used instead of a thrust loading diagram,
% since in the end the objective is to minimize wing size and/or engine
% size.
%
% All T/W and W/P values refer to the TOTAL installed thrust/power, i.e.
% the power or thrust is not expressed per engine. This is because the
% number of thermal engines and the number of propulsors may vary. All W
% values in the graphs are corrected to MTOW.
%   
% Note that in the comments, "propeller", "propulsor" and "fan" are used
% indistinctively. Furthermore, in the comments, "DP" does not mean the
% aircraft has to have an array of distributed propulsor as such. "DP"
% refers to a propulsive system which has significant aero-propulsive
% interaction effects (e.g. over-the-wing, BLI, tip-mounted,...) that have
% to be included in the design loop. These aero-propulsive interaction 
% effects are estimated in WingPropDeltas.m.
%
%%% Reynard de Vries
%%% TU Delft
%%% Date created: 21-06-17
%%% Last modified: 04-04-18


%% Evaluate constraints

% Speed constraint in cruise conditions (includes a ROC, to ensure
% start-of-climb is achievable at cruise M)
disp([s.levelString '  > Cruise constraint'])
[WS.cr,WP_path.cr,WP_comp.cr,WP_loss.cr,TW.cr,a,m,p] = ...
    ConstraintCruiseSpeed(a,m,p,f,s,c);

% Isolated wing stall speed
disp([s.levelString '  > Stall constraint'])
[WS.Liso,WP_path.Liso,WP_comp.Liso,WP_loss.Liso,TW.Liso,a,m,p] = ...
    ConstraintLandingStallSpeedWing(a,m,p,f,s,c);

% Powered wing stall speed
[WS.L,WP_path.L,WP_comp.L,WP_loss.L,TW.L,a,m,p] = ...
    ConstraintLandingStallSpeed(a,m,p,f,s,c);

% Take-off distance (1: TOP)
disp([s.levelString '  > Take-off constraint (TOP)'])
[WS.TO,WP_path.TO,WP_comp.TO,WP_loss.TO,TW.TO,a,m,p] = ...
    ConstraintTakeOffDistance(a,m,p,f,s,c);

% Balked landing with OEI
disp([s.levelString '  > OEI balked landing constraint'])
[WS.bL1,WS.bL2,WP_path.bL1,WP_comp.bL1,WP_loss.bL1,WP_path.bL2,WP_comp.bL2,...
    WP_loss.bL2,TW.bL,a,m,p] = ConstraintBalkedLandingOEI(a,m,p,f,s,c);

% Additional constraints which are not currently used
% % OEI ceiling (currently uses CLmax/vmargin^2, not L/D max!)
% disp([s.levelString '  > OEI ceiling constraint'])
% [WS.cI1,WS.cI2,WP_path.cI1,WP_comp.cI1,WP_loss.cI1,WP_path.cI2,WP_comp.cI2,...
%     WP_loss.cI2,TW.cI,a,m,p] = ConstraintCeilingOEI(a,m,p,f,s,c);
% 
% % Start-of-climb acceleration and ROC constraint
% disp([s.levelString '  > Start-of-climb constraint'])
% [WS.cl,WP_path.cl,WP_comp.cl,WP_loss.cl,TW.cl,a,m,p] = ...
%     ConstraintStartOfClimb(a,m,p,f,s,c);
% 
% % Top-of-climb acceleration and ROC constraint
% disp([s.levelString '  > Top-of-climb constraint'])
% [WS.ct,WP_path.ct,WP_comp.ct,WP_loss.ct,TW.ct,a,m,p] = ...
%     ConstraintTopOfClimb(a,m,p,f,s,c);

% Additional constraints which are not currently used
%{
% Cruise ceiling (currently uses CLmax/vmargin^2, not L/D max!)
disp([s.levelString '> Cruise ceiling constraint'])
[WS.cc,WP_path.cc,WP_comp.cc,WP_loss.cc,TW.cc,a,m,p] = ...
    ConstraintCeilingCruise(a,m,p,f,s,c);

% Time to climb (currently uses CLmax/vmargin^2, not L/D max! Also assumes
% constant climb rate) (THIS CONSTRAINT USES SAME STRUCTURE AS
% START-OF-CLIMB CONSTRAINT: DO NOT USE SIMULTANEOUSLY)
disp([s.levelString '> Time-to-climb constraint'])
m.cl.vMargin = 1.25;                            % Stall margin in climb conditions 
m.cl.ttc = 35*60;                               % Time-to-climb (to cruise ceiling) [s]
[WS.cl,WP_path.cl,WP_comp.cl,WP_loss.cl,TW.cl,a,m,p] = ...
    ConstraintTimeToClimb(a,m,p,f,s,c);

% Take-off distance (2: new method)
disp([s.levelString '> Take-off constraint (Torenbeek 2013)'])
[WS.TO2,WP_path.TO2,WP_comp.TO2,WP_loss.TO2,TW.TO2,a,m,p] = ...
    ConstraintTakeOffDistance_v2(a,m,p,f,s,c);
%}


%% Determine design points

% Manually establish which powers are important for the sizing process
names = fieldnames(WP_path);
for i = 1:size(names,1)
    WP_select.(names{i}).GT = WP_comp.(names{i}).GT;
    WP_select.(names{i}).GTM = WP_comp.(names{i}).GTM;
    WP_select.(names{i}).EM1 = WP_comp.(names{i}).EM1;
    WP_select.(names{i}).EM1M = WP_comp.(names{i}).EM1M;
    WP_select.(names{i}).EM2 = WP_comp.(names{i}).EM2;
    WP_select.(names{i}).EM2M = WP_comp.(names{i}).EM2M;
    WP_select.(names{i}).f = WP_path.(names{i}).f;
    WP_select.(names{i}).bat = WP_path.(names{i}).bat;
    WP_select.(names{i}).s1 = WP_path.(names{i}).s1;
    WP_select.(names{i}).s2 = WP_path.(names{i}).s2;
    WP_select.(names{i}).p = WP_path.(names{i}).p;
end
clear('names','i')

% Call function to compute design points
disp([s.levelString '  > Evaluating design point'])
[WSdes,WPdes,TW_WSdes,AEROdes,AC,~,a,m,p,s.figs] = ...
                    ComputeDesignPoint(WS,WP_select,TW,a,m,p,f,s);

% Check if thrust coefficient values are acceptable
disp([s.levelString '  > Verifying thrust coefficients'])
[s.figs(end+1),~] = PlotThrustCoefficients(WS,WP_path,WSdes,WPdes,a,m,p,f,s);    

